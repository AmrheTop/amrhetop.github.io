---
layout: post
title: "23种设计模式-三种工厂模式"
date: 2025-03-17T21:48:45+08:00
categories: []
tags: []
---

#### 一、简单介绍：三种工厂模式的定义与实现

1. **简单工厂模式（Simple Factory）**  
   简单工厂并非标准设计模式，而是工厂方法的一种简化形态。它通过一个**静态方法**或**工厂类**，根据输入参数（如类型标识）直接创建对象。  
   **示例**：假设需要生产不同品牌的汽车，工厂类通过判断参数（如“Benz”或“Ferrari”）返回对应车型实例。  
   **代码特点**：集中式逻辑，新增产品需修改工厂类代码，违反开闭原则。

2. **工厂方法模式（Factory Method）**  
   将对象创建延迟到子类，定义一个**抽象工厂接口**，由子类决定具体实例化的产品。  
   **示例**：不同地区的披萨店（北京店、天津店）继承自同一抽象工厂，各自实现创建披萨的方法。  
   **代码特点**：每新增一种产品需新增一个工厂类，但无需修改已有代码，符合开闭原则。

3. **抽象工厂模式（Abstract Factory）**  
   用于创建**一组相关或依赖的对象**（即产品族），提供一个接口生成多个关联产品。  
   **示例**：数据库访问组件需同时创建连接（Connection）和命令（Command）对象，抽象工厂可确保不同数据库（如MySQL、Oracle）的组件兼容。  
   **代码特点**：横向扩展产品族容易，但新增产品类型需修改接口及所有实现类。

---

#### 二、使用场景：何时选择何种模式？

1. **简单工厂模式**  
   - **适用场景**：产品类型固定、需求变化少的小型系统，如日志记录器、单数据库访问层。  
   - **局限**：新增产品需修改工厂逻辑，扩展性差，适用于产品生命周期稳定的场景。

2. **工厂方法模式**  
   - **适用场景**：需要灵活扩展单一产品的场景，例如多品牌家电生产、跨平台UI组件（如按钮、文本框）。  
   - **优势**：支持动态扩展，例如新增“特斯拉”汽车只需增加对应工厂类，无需改动客户端代码。

3. **抽象工厂模式**  
   - **适用场景**：需要创建**一组关联对象**的系统，如跨平台应用（Windows/Mac的窗口、菜单组合）、游戏引擎（角色、武器、场景风格一致性）。  
   - **典型案例**：Hibernate通过抽象工厂支持多种数据库方言，切换数据库时仅需更换工厂实现。

---

#### 三、总结对比与发散思考

| **维度**       | **简单工厂**       | **工厂方法**             | **抽象工厂**                   |
| -------------- | ------------------ | ------------------------ | ------------------------------ |
| **核心目标**   | 集中创建单一产品   | 动态扩展单一产品         | 创建关联产品族                 |
| **扩展性**     | 低（需修改工厂类） | 高（新增工厂类）         | 中（新增产品族易，产品类型难） |
| **代码复杂度** | 简单               | 较高（类数量多）         | 高（接口与实现类耦合）         |
| **适用场景**   | 小型系统、固定需求 | 中大型系统、单一产品扩展 | 复杂系统、产品族一致性需求     |

**发散思考**：  

1. **模式融合**：现代框架常结合多种工厂模式。例如Spring的`BeanFactory`本质是工厂方法模式，但通过配置（如XML或注解）实现类似抽象工厂的多组件管理。  
2. **设计原则**：工厂模式体现了**依赖倒置原则**（客户端依赖抽象而非具体类）和**单一职责原则**（创建逻辑与业务逻辑分离）。  
3. **未来趋势**：在云原生与微服务架构中，工厂模式常用于服务实例的动态创建（如Kubernetes的Pod工厂），支持弹性伸缩与多环境适配。

---

**结语**  
工厂模式的本质是**封装变化**，将对象的创建与使用解耦。选择哪种模式取决于系统的复杂度、扩展需求及产品关系。理解其核心思想，方能灵活应对需求迭代，构建高内聚、低耦合的代码体系。
